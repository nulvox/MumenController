//! Build script for processing configuration files
//!
//! This script processes TOML configuration files at compile time
//! and generates Rust code for the configurations.

use std::{env, fs, path::Path};
use serde::Deserialize;

// TOML configuration structures
#[derive(Deserialize)]
struct PinoutConfig {
    digital: std::collections::HashMap<String, u8>,
    analog: std::collections::HashMap<String, u8>,
    special: std::collections::HashMap<String, u8>,
}

#[derive(Deserialize)]
struct SocdConfig {
    resolution_methods: std::collections::HashMap<String, String>,
    custom_overrides: Option<std::collections::HashMap<String, String>>,
}

fn main() {
    println!("cargo:rerun-if-changed=config/");
    
    // Create the config directory if it doesn't exist
    let config_dir = Path::new("config");
    if !config_dir.exists() {
        fs::create_dir_all(config_dir).expect("Failed to create config directory");
        
        // Create subdirectories
        fs::create_dir_all(config_dir.join("pinout")).expect("Failed to create pinout config directory");
        fs::create_dir_all(config_dir.join("socd")).expect("Failed to create SOCD config directory");
        
        // Create default config files if they don't exist (simple fallbacks)
        if !config_dir.join("pinout/default.toml").exists() {
            // This content should be minimal - we expect real configs to be more detailed
            let default_pinout = r#"
[digital]
button_a = 2
button_b = 3

[analog]
left_stick_x = 23
left_stick_y = 22

[special]
lock_pin = 33
"#;
            fs::write(config_dir.join("pinout/default.toml"), default_pinout)
                .expect("Failed to write default pinout config");
        }
        
        if !config_dir.join("socd/default.toml").exists() {
            let default_socd = r#"
[resolution_methods]
left_right = "neutral"
up_down = "up-priority"

[custom_overrides]
"#;
            fs::write(config_dir.join("socd/default.toml"), default_socd)
                .expect("Failed to write default SOCD config");
        }
    }
    
    // Path for the generated Rust code
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated_config.rs");
    
    // Read configuration files
    let pinout_config = read_pinout_config("default");
    let socd_config = read_socd_config("default");
    
    // Generate Rust code from configurations
    let generated_code = generate_config_code(&pinout_config, &socd_config);
    
    // Write the generated code to the output file
    fs::write(dest_path, generated_code).expect("Failed to write generated config");
    
    println!("cargo:warning=Build script executed successfully");
}

/// Read pinout configuration from the specified file
fn read_pinout_config(config_name: &str) -> PinoutConfig {
    let config_path = Path::new("config/pinout").join(format!("{}.toml", config_name));
    
    let config_text = fs::read_to_string(&config_path)
        .unwrap_or_else(|_| panic!("Failed to read pinout config: {}", config_path.display()));
    
    let config: PinoutConfig = toml::from_str(&config_text)
        .unwrap_or_else(|e| panic!("Failed to parse pinout config: {}", e));
        
    println!("cargo:warning=Loaded pinout configuration: {}", config_name);
    config
}

/// Read SOCD configuration from the specified file
fn read_socd_config(config_name: &str) -> SocdConfig {
    let config_path = Path::new("config/socd").join(format!("{}.toml", config_name));
    
    let config_text = fs::read_to_string(&config_path)
        .unwrap_or_else(|_| panic!("Failed to read SOCD config: {}", config_path.display()));
    
    let config: SocdConfig = toml::from_str(&config_text)
        .unwrap_or_else(|e| panic!("Failed to parse SOCD config: {}", e));
        
    println!("cargo:warning=Loaded SOCD configuration: {}", config_name);
    config
}

/// Generate Rust code from configurations
fn generate_config_code(pinout: &PinoutConfig, socd: &SocdConfig) -> String {
    // Start with file header comments
    let mut code = String::from(r#"//! GENERATED CODE - DO NOT EDIT MANUALLY
//!
//! This file was generated by build.rs from TOML configuration files.
//! Edit the source TOML files instead.

/// Pinout configuration constants and accessors
#[derive(Debug)]
pub struct PinoutConfig;

/// Digital input pin mapping constants
pub mod digital_pins {
"#);

    // Generate digital pin constants
    for (name, pin) in &pinout.digital {
        code.push_str(&format!("    /// Pin number for the {} button\n", name));
        code.push_str(&format!("    pub const {}: u8 = {};\n\n", name.to_uppercase(), pin));
    }
    
    code.push_str("}\n\n/// Analog input pin mapping constants\npub mod analog_pins {\n");
    
    // Generate analog pin constants
    for (name, pin) in &pinout.analog {
        code.push_str(&format!("    /// Pin number for the {} axis\n", name));
        code.push_str(&format!("    pub const {}: u8 = {};\n\n", name.to_uppercase(), pin));
    }
    
    code.push_str("}\n\n/// Special pins for additional functionality\npub mod special_pins {\n");
    
    // Generate special pin constants
    for (name, pin) in &pinout.special {
        code.push_str(&format!("    /// Pin number for {} functionality\n", name));
        code.push_str(&format!("    pub const {}: u8 = {};\n\n", name.to_uppercase(), pin));
    }
    
    // Implementation for PinoutConfig
    code.push_str(r#"
}

impl PinoutConfig {
    /// Get all digital pin mappings as (name, pin) pairs
    pub fn get_digital_pins() -> &'static [(&'static str, u8)] {
        &[
"#);

    // Add all digital pin mappings
    for (name, pin) in &pinout.digital {
        code.push_str(&format!("            (\"{}\", {}),\n", name, pin));
    }

    code.push_str(r#"        ]
    }

    /// Get all analog pin mappings as (name, pin) pairs
    pub fn get_analog_pins() -> &'static [(&'static str, u8)] {
        &[
"#);

    // Add all analog pin mappings
    for (name, pin) in &pinout.analog {
        code.push_str(&format!("            (\"{}\", {}),\n", name, pin));
    }

    code.push_str(r#"        ]
    }

    /// Get all special pin mappings as (name, pin) pairs
    pub fn get_special_pins() -> &'static [(&'static str, u8)] {
        &[
"#);

    // Add all special pin mappings
    for (name, pin) in &pinout.special {
        code.push_str(&format!("            (\"{}\", {}),\n", name, pin));
    }

    // SOCD Configuration
    code.push_str(r#"        ]
    }
}

/// SOCD handling configuration constants and accessors
#[derive(Debug)]
pub struct SocdConfig;

/// SOCD resolution method constants
pub mod socd_methods {
    /// Both inputs are neutralized
    pub const NEUTRAL: &str = "neutral";
    /// Last input wins
    pub const LAST_WIN: &str = "last-win";
    /// First input wins
    pub const FIRST_WIN: &str = "first-win";
    /// Up has priority over down
    pub const UP_PRIORITY: &str = "up-priority";
    /// Second input overrides the first
    pub const SECOND_PRIORITY: &str = "second-input-priority";
}

impl SocdConfig {
    /// Get SOCD resolution methods as (input_pair, method) pairs
    pub fn get_resolution_methods() -> &'static [(&'static str, &'static str)] {
        &[
"#);

    // Add all SOCD resolution methods
    for (pair, method) in &socd.resolution_methods {
        code.push_str(&format!("            (\"{}\", \"{}\"),\n", pair, method));
    }

    code.push_str(r#"        ]
    }

    /// Get custom SOCD overrides as (input_combo, result) pairs
    pub fn get_custom_overrides() -> &'static [(&'static str, &'static str)] {
        &[
"#);

    // Add all custom overrides if they exist
    if let Some(overrides) = &socd.custom_overrides {
        for (combo, result) in overrides {
            code.push_str(&format!("            (\"{}\", \"{}\"),\n", combo, result));
        }
    }

    code.push_str(r#"        ]
    }

    /// Get the resolution method for a specific input pair
    pub fn get_method_for_pair(pair: &str) -> &'static str {
        match pair {
"#);

    // Add match arms for each resolution method
    for (pair, method) in &socd.resolution_methods {
        code.push_str(&format!("            \"{}\" => \"{}\",\n", pair, method));
    }

    // Default case and closing
    code.push_str(r#"            _ => "neutral", // Default to neutral if not specified
        }
    }
}
"#);

    code
}